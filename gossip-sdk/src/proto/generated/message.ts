// Generated by protoc from: src/proto/message.proto
// Do not edit manually.

export enum MessageType {
  MESSAGE_TYPE_REGULAR = 0,
  MESSAGE_TYPE_REPLY = 1,
  MESSAGE_TYPE_FORWARD = 2,
  MESSAGE_TYPE_KEEP_ALIVE = 3,
}

export interface Message {
  messageType?: MessageType;
  messageId?: Uint8Array;
  content?: string;
  citedMsgId?: Uint8Array;
  citedContactId?: Uint8Array;
  forwardedContent?: string;
}

const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();

function encodeVarint(value: number, out: number[]) {
  let v = value >>> 0;
  while (v >= 0x80) {
    out.push((v & 0x7f) | 0x80);
    v >>>= 7;
  }
  out.push(v);
}

function decodeVarint(buffer: Uint8Array, offset: number) {
  let result = 0;
  let shift = 0;
  let pos = offset;
  while (pos < buffer.length) {
    const byte = buffer[pos++];
    result |= (byte & 0x7f) << shift;
    if ((byte & 0x80) === 0) {
      return { value: result >>> 0, offset: pos };
    }
    shift += 7;
    if (shift > 35) {
      throw new Error('Varint too long');
    }
  }
  throw new Error('Truncated varint');
}

function writeBytes(fieldNumber: number, bytes: Uint8Array, out: number[]) {
  encodeVarint((fieldNumber << 3) | 2, out);
  encodeVarint(bytes.length, out);
  for (let i = 0; i < bytes.length; i++) {
    out.push(bytes[i]);
  }
}

function writeString(fieldNumber: number, value: string, out: number[]) {
  const bytes = textEncoder.encode(value);
  writeBytes(fieldNumber, bytes, out);
}

function skipField(wireType: number, buffer: Uint8Array, offset: number) {
  switch (wireType) {
    case 0: {
      return decodeVarint(buffer, offset).offset;
    }
    case 2: {
      const { value: length, offset: nextOffset } = decodeVarint(
        buffer,
        offset
      );
      return nextOffset + length;
    }
    default:
      throw new Error(`Unsupported wire type: ${wireType}`);
  }
}

export const Message = {
  encode(message: Message): Uint8Array {
    const out: number[] = [];

    if (message.messageType !== undefined) {
      encodeVarint(1 << 3, out);
      encodeVarint(message.messageType, out);
    }

    if (message.messageId !== undefined) {
      writeBytes(2, message.messageId, out);
    }

    if (message.content !== undefined) {
      writeString(3, message.content, out);
    }

    if (message.citedMsgId !== undefined) {
      writeBytes(4, message.citedMsgId, out);
    }

    if (message.citedContactId !== undefined) {
      writeBytes(5, message.citedContactId, out);
    }

    if (message.forwardedContent !== undefined) {
      writeString(6, message.forwardedContent, out);
    }

    return new Uint8Array(out);
  },

  decode(buffer: Uint8Array): Message {
    const message: Message = { content: '' };
    let offset = 0;

    while (offset < buffer.length) {
      const { value: key, offset: nextOffset } = decodeVarint(buffer, offset);
      offset = nextOffset;
      const fieldNumber = key >> 3;
      const wireType = key & 0x7;

      switch (fieldNumber) {
        case 1: {
          const result = decodeVarint(buffer, offset);
          message.messageType = result.value as MessageType;
          offset = result.offset;
          break;
        }
        case 2: {
          const { value: length, offset: lengthOffset } = decodeVarint(
            buffer,
            offset
          );
          const end = lengthOffset + length;
          message.messageId = buffer.slice(lengthOffset, end);
          offset = end;
          break;
        }
        case 3: {
          const { value: length, offset: lengthOffset } = decodeVarint(
            buffer,
            offset
          );
          const end = lengthOffset + length;
          message.content = textDecoder.decode(buffer.slice(lengthOffset, end));
          offset = end;
          break;
        }
        case 4: {
          const { value: length, offset: lengthOffset } = decodeVarint(
            buffer,
            offset
          );
          const end = lengthOffset + length;
          message.citedMsgId = buffer.slice(lengthOffset, end);
          offset = end;
          break;
        }
        case 5: {
          const { value: length, offset: lengthOffset } = decodeVarint(
            buffer,
            offset
          );
          const end = lengthOffset + length;
          message.citedContactId = buffer.slice(lengthOffset, end);
          offset = end;
          break;
        }
        case 6: {
          const { value: length, offset: lengthOffset } = decodeVarint(
            buffer,
            offset
          );
          const end = lengthOffset + length;
          message.forwardedContent = textDecoder.decode(
            buffer.slice(lengthOffset, end)
          );
          offset = end;
          break;
        }
        default:
          offset = skipField(wireType, buffer, offset);
      }
    }

    return message;
  },
};
