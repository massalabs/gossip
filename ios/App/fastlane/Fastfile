# Fastfile for Gossip iOS App

default_platform(:ios)

platform :ios do
  # Private lane containing common build logic
  private_lane :build_app_common do
    # Setup CI environment (creates temporary keychain)
    setup_ci if ENV['CI']
    
    # Create API Key for App Store Connect authentication (if available)
    api_key = nil
    if ENV['APP_STORE_CONNECT_API_KEY_KEY_ID'] && ENV['APP_STORE_CONNECT_API_KEY_ISSUER_ID'] && ENV['APP_STORE_CONNECT_API_KEY_KEY']
      api_key = app_store_connect_api_key(
        key_id: ENV['APP_STORE_CONNECT_API_KEY_KEY_ID'],
        issuer_id: ENV['APP_STORE_CONNECT_API_KEY_ISSUER_ID'],
        key_content: ENV['APP_STORE_CONNECT_API_KEY_KEY'],
        is_key_content_base64: false
      )
    end

    # Get the latest build number from TestFlight and increment by 1
    # This ensures we never conflict with already uploaded builds
    latest_build = latest_testflight_build_number(
      api_key: api_key,
      app_identifier: "net.massa.gossip",
      initial_build_number: 0
    )
    
    increment_build_number(
      build_number: latest_build + 1
    )
    
    # Use match for code signing
    # In CI, create App Store distribution profiles for both the main app and the iOS share extension
    match(
      type: "appstore",  # App Store type for TestFlight distribution
      readonly: false,   # Create certificates if needed
      app_identifier: [
        "net.massa.gossip",
        "net.massa.gossip.GossipShareExtension"
      ],
      api_key: api_key   # Use API Key for authentication
    )

    # Force manual signing for both targets using the appropriate App Store profiles
    # Main app target
    update_code_signing_settings(
      use_automatic_signing: false,
      path: "App.xcodeproj",
      team_id: ENV["APPLE_TEAM_ID"],
      targets: ["Gossip"],
      profile_name: "match AppStore net.massa.gossip",
      code_sign_identity: "Apple Distribution",
      bundle_identifier: "net.massa.gossip"
    )

    # Share extension target
    update_code_signing_settings(
      use_automatic_signing: false,
      path: "App.xcodeproj",
      team_id: ENV["APPLE_TEAM_ID"],
      targets: ["GossipShareExtension"],
      profile_name: "match AppStore net.massa.gossip.GossipShareExtension",
      code_sign_identity: "Apple Distribution",
      bundle_identifier: "net.massa.gossip.GossipShareExtension"
    )
    
    # Build the app with manual signing using Match certificates
    build_app(
      workspace: "App.xcworkspace",
      scheme: "Gossip",
      configuration: "Release",
      export_method: "app-store",
      output_directory: "fastlane/build",
      output_name: "Gossip.ipa",
      clean: false,
      export_options: {
        method: "app-store",
        provisioningProfiles: {
          "net.massa.gossip" => "match AppStore net.massa.gossip"
        },
        teamID: ENV["APPLE_TEAM_ID"]
      }
    )

    UI.success("‚úÖ Build completed successfully!")
  end

  desc "Build the iOS app"
  lane :build do
    build_app_common
  end

  desc "Build and upload to TestFlight"
  lane :beta do
    # Build the app using common logic
    build_app_common

    # Create API Key for App Store Connect authentication (if available)
    api_key = nil
    if ENV['APP_STORE_CONNECT_API_KEY_KEY_ID'] && ENV['APP_STORE_CONNECT_API_KEY_ISSUER_ID'] && ENV['APP_STORE_CONNECT_API_KEY_KEY']
      api_key = app_store_connect_api_key(
        key_id: ENV['APP_STORE_CONNECT_API_KEY_KEY_ID'],
        issuer_id: ENV['APP_STORE_CONNECT_API_KEY_ISSUER_ID'],
        key_content: ENV['APP_STORE_CONNECT_API_KEY_KEY'],
        is_key_content_base64: false
      )
    end

    # Upload to TestFlight
    upload_to_testflight(
      api_key: api_key,
      skip_waiting_for_build_processing: ENV["FASTLANE_SKIP_WAITING_FOR_BUILD_PROCESSING"] == "true",
      skip_submission: true,
      distribute_external: false,
      notify_external_testers: false,
      ipa: "fastlane/build/Gossip.ipa"
    )

    UI.success("üöÄ Successfully uploaded to TestFlight!")
  end

  desc "Download certificates and provisioning profiles using match"
  lane :setup_signing do
    UI.message("Setting up code signing with match...")
    
    match(
      type: "appstore",
      app_identifier: "net.massa.gossip"
    )
    
    UI.success("‚úÖ Code signing setup completed!")
  end
  
  desc "Create new certificates and provisioning profiles"
  lane :match_init do
    UI.message("Creating certificates with match...")
    
    match(
      type: "appstore",
      app_identifier: "net.massa.gossip"
    )
    
    UI.success("‚úÖ Certificates created and stored in git!")
  end

  # Error handling
  error do |lane, exception|
    UI.error("‚ùå Error in lane '#{lane}': #{exception.message}")
  end
end

